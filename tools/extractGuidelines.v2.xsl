<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns:egx="http://www.tei-c.org/ns/Examples"
    xmlns:xhtml="http://www.w3.org/1999/xhtml"
    xmlns:rng="http://relaxng.org/ns/structure/1.0"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    xmlns:saxon="http://saxon.sf.net/"
    xmlns:mei="http://www.music-encoding.org/ns/mei"
    xmlns:tools="local"
    exclude-result-prefixes="xs math xd xhtml tei rng sch egx saxon mei tools"
    version="3.0">
    <xd:doc scope="stylesheet">
        <xd:desc>
            <xd:p><xd:b>Created on:</xd:b> Nov 16, 2018</xd:p>
            <xd:p><xd:b>Author:</xd:b> Johannes Kepper</xd:p>
            <xd:p>
                This XSL generates HTML / Markdown output for the website version of the MEI 
                Guidelines from a canonicalized ODD file. It's a complete rewrite and focusses 
                solely on the website (no code for generating PDFs anymore). 
            </xd:p>
        </xd:desc>
    </xd:doc>
    
    <xsl:output indent="true" method="html" saxon:suppress-indentation="egx:egXML tei:classes tei:content tei:list tei:item" name="html" omit-xml-declaration="true"/>
    
    <xsl:param name="version" select="'{{ site.baseurl }}/{{ page.version }}'" as="xs:string"/>
    <xsl:param name="guidelines.version" select="'v4'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $image.prefix is a general prefix prepended to all image paths generated by this stylesheet.
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:param name="image.prefix" as="xs:string">
        <xsl:value-of select="'{{ site.baseurl }}/images/{{ page.version }}/'"/>
    </xsl:param>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $output.folder is the base folder where all outputs will be stored.
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:variable name="output.folder" select="'../' || $guidelines.version || '/'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $includes.folder is the folder where all descriptions and examples will be stored
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:variable name="includes.folder" select="'../_includes/' || $guidelines.version || '/'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $mei.source makes the input of this XSL (unmodified compiled ODD) available in a variable. 
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:variable name="mei.source" select="/" as="node()"/>
    
    <xsl:variable name="elements" select="$mei.source//tei:elementSpec" as="node()*"/>
    <xsl:variable name="att.classes" select="$mei.source//tei:classSpec[@type = 'atts']" as="node()*"/>
    <xsl:variable name="model.classes" select="$mei.source//tei:classSpec[@type = 'model']" as="node()*"/>
    <xsl:variable name="data.types" select="$mei.source//tei:macroSpec[@type = 'dt']" as="node()*"/>
    <xsl:variable name="macro.groups" select="$mei.source//tei:macroSpec[@type = 'pe']" as="node()*"/>
    <xsl:variable name="links.to.elements" as="node()*">
        <xsl:for-each select="$elements">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:variable name="ident" select="@ident"/>
            <a class="link_odd_elementSpec chip {substring($ident,1,1)}" href="{$version}/elements/{lower-case($ident)}.html"><xsl:value-of select="$ident"/></a>
        </xsl:for-each>
    </xsl:variable>
    
    
    <xsl:variable name="guidelines.references">
        <xsl:variable name="file.path" select="substring-before(document-uri(),'/tools/')"/>
        
        <xsl:for-each select="for $filename in uri-collection($file.path || '/_guidelines-' || $guidelines.version || '/?select=*.md;recurse=yes') return $filename">
            <!--<xsl:variable name="file.content" select="normalize-space(saxon:base64Binary-to-string(.,'UTF-8'))" as="xs:string"/>-->
            <xsl:variable name="full.path" select="string(.)" as="xs:string"/>
            <xsl:variable name="relevant.path" select="substring-after($full.path,$file.path || '/_guidelines-' || $guidelines.version || '/')" as="xs:string"/>
            <xsl:variable name="segments" select="tokenize($relevant.path,'/')" as="xs:string*"/>
            <xsl:variable name="chapter.num" select="string-join((for $segment in $segments return substring-before(replace($segment,'^0',''),'-')),'.')" as="xs:string"/>
            <xsl:variable name="sort.num" select="string-join((for $segment in $segments return substring-before($segment,'-')),'.')" as="xs:string"/>
            
            <xsl:variable name="file" select="unparsed-text($full.path,'UTF-8')" as="xs:string"/>
            <xsl:variable name="title">
                <xsl:analyze-string select="$file" regex="title: &quot;([\da-zA-Z -–,\(\)\.]*)&quot;">
                    <xsl:matching-substring>
                        <xsl:value-of select="regex-group(1)"/>
                    </xsl:matching-substring>
                </xsl:analyze-string>
            </xsl:variable>
            <xsl:variable name="section.id">
                <xsl:analyze-string select="$file" regex="sectionid: ([\da-zA-Z -–,\(\)\.]+)">
                    <xsl:matching-substring>
                        <xsl:value-of select="regex-group(1)"/>
                    </xsl:matching-substring>
                </xsl:analyze-string>
            </xsl:variable>
            <xsl:variable name="link" select="'/guidelines/' || $guidelines.version || '/content/' || replace(substring-after($segments[1],'-'),'.md$','') || '.html#' || $section.id" as="xs:string"/>
            <xsl:variable name="elements" as="xs:string*">
                <xsl:analyze-string select="$file" regex="% include (desc|link) elem=&quot;([a-zA-Z\d]+)&quot; %">
                    <xsl:matching-substring>
                        <xsl:value-of select="regex-group(2)"/>
                    </xsl:matching-substring>
                </xsl:analyze-string>
            </xsl:variable>
            
            <xsl:for-each select="distinct-values($elements)">
                <ref ident="{.}" link="{$link}" type="element" chapter="{$chapter.num} {$title}" sortnum="{$sort.num}"/>
            </xsl:for-each>
            <!--<xsl:message select="$link || ' has ' || count(distinct-values($elements)) || ' links: ' || string-join(distinct-values($elements),', ')"/>-->
        </xsl:for-each>
        
    </xsl:variable>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                This is where processing starts.
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:template match="/">
        
        <xsl:message select="'INFO: $output.folder is ' || $output.folder || ', $includes.folder is ' || $includes.folder"/>
        
        <!-- handling of elements -->
        <xsl:for-each select="$mei.source//tei:elementSpec">
            <xsl:variable name="element" select="."/>
            
            <!-- create desc snippet in _includes for inclusion in guidelines -->
            <xsl:variable name="path" select="$includes.folder || 'desc/' || @ident || '.txt'" as="xs:string"/>
            <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes">
                <xsl:apply-templates select="./tei:desc/node()" mode="plain"/>
            </xsl:result-document>
            
            <!-- create desc snippets in _includes for all directly defined attributes -->
            <xsl:for-each select=".//tei:attDef">
                <xsl:variable name="path" select="$includes.folder || 'desc/' || $element/@ident || '/' || replace(@ident,':','---') || '.txt'" as="xs:string"/>
                <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes">
                    <xsl:apply-templates select="./tei:desc/node()" mode="plain"/>
                </xsl:result-document>
            </xsl:for-each>
            
            <xsl:call-template name="processObject">
                <xsl:with-param name="object" select="$element"/>
            </xsl:call-template>
        </xsl:for-each>
        
        
        
    </xsl:template>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                This function generates the required output page for an object, depending on its type
            </xd:p>
        </xd:desc>
        <xd:param name="object">
            <xd:p>This is the object which needs to be processed.</xd:p>
        </xd:param>
    </xd:doc>
    <xsl:template name="processObject">
        <xsl:param name="object" as="node()"/>
        
        <!-- identifies type of object -->
        <xsl:variable name="type" as="xs:string">
            <xsl:choose>
                <xsl:when test="local-name($object) = 'elementSpec'">
                    <xsl:value-of select="'element'"/>
                </xsl:when>
                <xsl:when test="local-name($object) = 'classSpec' and $object/@type = 'atts'">
                    <xsl:value-of select="'class.atts'"/>
                </xsl:when>
                <xsl:when test="local-name($object) = 'classSpec' and $object/@type = 'model'">
                    <xsl:value-of select="'class.model'"/>
                </xsl:when>
                <xsl:when test="local-name($object) = 'macroSpec' and $object/@type = 'dt'">
                    <xsl:value-of select="'macro.dt'"/>
                </xsl:when>
                <xsl:when test="local-name($object) = 'macroSpec' and $object/@type = 'pe'">
                    <xsl:value-of select="'macro.pe'"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        
        <!-- the folder where this object needs to go, depending on its type -->
        <xsl:variable name="object.folder" as="xs:string">
            <xsl:choose>
                <xsl:when test="$type = 'element'">
                    <xsl:value-of select="'elements/'"/>
                </xsl:when>
                <xsl:when test="$type = 'class.atts'">
                    <xsl:value-of select="'attribute-classes/'"/>
                </xsl:when>
                <xsl:when test="$type = 'class.model'">
                    <xsl:value-of select="'model-classes/'"/>
                </xsl:when>
                <xsl:when test="$type = 'macro.dt'">
                    <xsl:value-of select="'data-types/'"/>
                </xsl:when>
                <xsl:when test="$type = 'macro.pe'">
                    <xsl:value-of select="'data-types/'"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="target.folder" select="$output.folder || $object.folder" as="xs:string"/>
        <xsl:result-document href="{$target.folder || lower-case($object/@ident)}.md" format="html">
            <xsl:text>---</xsl:text>
            <xsl:text>&#xa;</xsl:text>
            <xsl:text>layout: sidebar</xsl:text>
            <xsl:text>&#xa;</xsl:text>
            <xsl:text>sidebar: s1</xsl:text>
            <xsl:text>&#xa;</xsl:text>
            <xsl:text>version: "</xsl:text><xsl:value-of select="$guidelines.version"/><xsl:text>"</xsl:text>
            <xsl:text>&#xa;</xsl:text>
            <xsl:text>title: "</xsl:text><xsl:value-of select="$object/@ident"/><xsl:text>"</xsl:text>
            <xsl:text>&#xa;</xsl:text>
            <xsl:text>---</xsl:text>
            <xsl:text>&#xa;</xsl:text>
            <xsl:apply-templates select="$object" mode="parse.odd"/>
        </xsl:result-document>
        
    </xsl:template>
    
    <xd:doc scope="component">
        <xd:desc>This template resolves elements</xd:desc>
    </xd:doc>
    <xsl:template match="tei:elementSpec" mode="parse.odd">
        <xsl:variable name="element" select="." as="node()"/>
        <div class="elementSpec">
            <h3 id="{$element/@ident}">&lt;<xsl:value-of select="$element/@ident"/>&gt;</h3>
            <div class="specs">
                <div class="desc">
                    <xsl:apply-templates select="$element/tei:desc/node()" mode="#current"/>
                    <xsl:variable name="refs" select="$guidelines.references/descendant-or-self::*:ref[@ident = $element/@ident]" as="node()*"/>
                    <xsl:if test="count($refs) gt 0">
                        <div class="chapterLinksBox">
                            <xsl:for-each select="$refs">
                                <xsl:sort select="@sortnum" data-type="text"/>
                                <a class="chapterLink" href="{@link}"><xsl:value-of select="@chapter"/></a><xsl:if test="position() lt count($refs)">,</xsl:if>
                            </xsl:for-each>
                        </div>
                    </xsl:if>
                </div>
                <div class="facet module">
                    <div class="label">Module</div>
                    <div class="statement text">
                        <xsl:value-of select="$element/@module"/>
                    </div>
                </div>
                <div class="facet attributes" id="attributes">
                    <div class="label">Attributes</div>
                    <div class="statement classes list">
                        <ul class="tab">
                            <li class="tab-item">
                                <a data-attDisplay="compact" id="attDisplay_compact_tab" href="#attributes" class="attDisplay_tab active">compact</a>
                            </li>
                            <li class="tab-item">
                                <a data-attDisplay="full" id="attDisplay_full_tab" href="#attributes" class="attDisplay_tab">full definition</a>
                            </li>
                            <li class="tab-item">
                                <a data-attDisplay="class" id="attDisplay_class_tab" href="#attributes" class="attDisplay_tab">by class</a>
                            </li>
                            <li class="tab-item">
                                <a data-attDisplay="module" id="attDisplay_module_tab" href="#attributes" class="attDisplay_tab">by module</a>
                            </li>
                        </ul>
                        
                        <xsl:variable name="attributes" as="node()*">
                            <xsl:sequence select="tools:handleAttributes($element)"/>
                        </xsl:variable>
                        
                        <div id="attDisplay_compact" class="attDisplay active facetTabbedContent">
                            <xsl:for-each select="$attributes//descendant-or-self::div[@class = 'attributeDef']">
                                <xsl:sort select="@data-ident" data-type="text"/>
                                <xsl:if test="position() gt 1">
                                    <xsl:value-of select="', '"/>
                                </xsl:if>
                                <xsl:sequence select="./span[@class='ident attribute']"/>
                            </xsl:for-each>
                        </div>
                        <div id="attDisplay_full" class="attDisplay facetTabbedContent">
                            <xsl:for-each select="$attributes//descendant-or-self::div[@class = 'attributeDef']">
                                <xsl:sort select="@data-ident" data-type="text"/>
                                <xsl:sequence select="."/>
                            </xsl:for-each>
                        </div>
                        <div id="attDisplay_class" class="attDisplay facetTabbedContent">
                            <xsl:sequence select="$attributes"/>
                        </div>
                        <div id="attDisplay_module" class="attDisplay facetTabbedContent">
                            <xsl:for-each select="distinct-values($attributes//descendant-or-self::div[@class = 'attributeDef']/@data-module)">
                                <xsl:sort select="." data-type="text"/>
                                <xsl:variable name="current.module" select="." as="xs:string"/>
                                <div class="moduleBox">
                                    <div class="classHeading">
                                        <label class="groupLabel"><xsl:value-of select="$current.module"/></label>
                                        <span class="groupDesc"><xsl:value-of select="normalize-space(string-join($mei.source//tei:moduleSpec[@ident = $current.module]/tei:desc/text(),' '))"/></span>
                                    </div>
                                    
                                    <xsl:for-each select="$attributes//descendant-or-self::div[@class = 'attributeDef'][@data-module = $current.module]">
                                        <xsl:sort select="@data-ident" data-type="text"/>
                                        <xsl:sequence select="."/>
                                    </xsl:for-each>
                                </div>
                            </xsl:for-each>
                        </div>
                    </div>
                </div>
                <div class="facet memberships">
                    <div class="label">Member of</div>
                    <div class="statement memberships">
                        <xsl:for-each select="$element//tei:memberOf[starts-with(@key,'model.')]">
                            <xsl:variable name="key" select="@key" as="xs:string"/>
                            <xsl:variable name="key.lowercase" select="lower-case($key)" as="xs:string"/>
                            <xsl:variable name="model.desc" select="normalize-space(string-join($model.classes/self::tei:classSpec[@ident = $key]/tei:desc/text(),' '))" as="xs:string"/>
                            <div class="memberOf">
                                <a class="link_odd_classSpec" href="{$version}/model-classes/{$key.lowercase}.html"><xsl:value-of select="@key"/></a>
                                <span class="groupDesc"><xsl:value-of select="$model.desc"/></span>
                            </div>
                        </xsl:for-each>
                    </div>
                </div>
                <div class="facet containedBy" id="containedBy">
                    <div class="label">Contained by</div>
                    <div class="statement containedBy list">
                        
                        <xsl:variable name="direct.parents" select="$elements/self::tei:elementSpec[.//tei:content//rng:ref[@name = $element/@ident]]" as="node()*"/>
                        <xsl:variable name="class.parents" select="tools:getParents($model.classes/self::tei:classSpec[@ident = $element//tei:memberOf[starts-with(@key,'model.')]/@key])" as="node()*"/>
                        <xsl:variable name="macro.parents" select="tools:getParents($macro.groups/self::tei:macroSpec[.//tei:content//rng:ref[@name = $element/@ident]])" as="node()*"/>
                        
                        <xsl:variable name="parents" select="$direct.parents | $class.parents | $macro.parents" as="node()*"/>
                        
                        
                        <ul class="tab">
                            <li class="tab-item">
                                <a data-containedByDisplay="compact" id="containedByDisplay_compact_tab" href="#containedBy" class="containedByDisplay_tab active">compact</a>
                            </li>
                            <li class="tab-item">
                                <a data-containedByDisplay="module" id="containedByDisplay_module_tab" href="#containedBy" class="containedByDisplay_tab">by module</a>
                            </li>
                        </ul>
                            
                        <div id="containedByDisplay_compact" class="containedByDisplay active facetTabbedContent">
                            <xsl:for-each select="$parents/self::tei:elementSpec">
                                <xsl:sort select="@ident" data-type="text"/>
                                <xsl:variable name="current.elem" select="@ident" as="xs:string"/>
                                <xsl:variable name="current.elem.lowercase" select="lower-case($current.elem)" as="xs:string"/>
                                <xsl:variable name="desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string"/>
                                <xsl:if test="position() gt 1">
                                    <xsl:value-of select="', '"/>
                                </xsl:if>
                                <span class="ident element" title="{$desc}">
                                    <a class="link_odd_elementSpec" href="{$version}/elements/{$current.elem.lowercase}.html"><xsl:value-of select="$current.elem"/></a>
                                </span>
                            </xsl:for-each>
                        </div>
                        <div id="containedByDisplay_module" class="containedByDisplay facetTabbedContent">
                            <xsl:for-each select="distinct-values($parents/self::tei:elementSpec/@module)">
                                <xsl:sort select="." data-type="text"/>
                                <xsl:variable name="current.module" select="." as="xs:string"/>
                                <xsl:variable name="relevant.element.names" select="distinct-values($parents/self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                                <div class="moduleBox">
                                    <div class="classHeading">
                                        <label class="groupLabel"><xsl:value-of select="$current.module"/></label>
                                        <span class="groupDesc"><xsl:value-of select="normalize-space(string-join($mei.source//tei:moduleSpec[@ident = $current.module]/tei:desc/text(),' '))"/></span>
                                    </div>
                                    
                                    <xsl:for-each select="$relevant.element.names">
                                        <xsl:sort select="." data-type="text"/>
                                        <xsl:variable name="current.elem" select="." as="xs:string"/>
                                        <xsl:variable name="current.elem.lowercase" select="lower-case(.)" as="xs:string"/>
                                        
                                        <div class="elementRef">
                                            <a class="link_odd_elementSpec" href="{$version}/elements/{$current.elem.lowercase}.html"><xsl:value-of select="$current.elem"/></a>
                                            <span class="elementDesc">
                                                <xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $current.elem]/tei:desc" mode="#current"/>
                                            </span>
                                        </div>
                                    </xsl:for-each>
                                    
                                </div> 
                                
                            </xsl:for-each>
                        </div>
                        
                    </div>
                </div>
                
                <div class="facet contains" id="contains">
                    <div class="label">May contain</div>
                    <div class="statement contains list">
                        
                        <xsl:variable name="direct.childs" select="$elements/self::tei:elementSpec[@ident = $element//tei:content//rng:ref[not(starts-with(@name,'model.'))]/@name]" as="node()*"/>
                        <xsl:variable name="class.childs" as="node()*">
                            <xsl:for-each select="$element//tei:content//rng:ref[starts-with(@name,'model.')]">
                                <xsl:variable name="modelClass.name" select="@name" as="xs:string"/>
                                <xsl:sequence select="tools:getChilds($modelClass.name)"/>
                            </xsl:for-each>
                        </xsl:variable>
                        <xsl:variable name="macro.childs" as="node()*">
                            <xsl:for-each select="$element//tei:content//rng:ref[starts-with(@name,'macro.')]">
                                <xsl:variable name="macroSpec.name" select="@name" as="xs:string"/>
                                <xsl:variable name="macroSpec" select="$macro.groups/self::tei:macroSpec[@ident = $macroSpec.name]" as="node()?"/>
                                <xsl:if test="not($macroSpec)">
                                    <xsl:message select="$macroSpec.name || ' missing at ' || $element/@ident" terminate="yes"/>
                                </xsl:if>
                                <xsl:sequence select="$elements/self::tei:elementSpec[@ident = $macroSpec//tei:content//rng:ref/@name]"/>    
                            </xsl:for-each>
                        </xsl:variable>
                        
                        <xsl:variable name="childs" select="$direct.childs | $class.childs | $macro.childs" as="node()*"/>
                        
                        <ul class="tab">
                            <li class="tab-item">
                                <a data-containsDisplay="compact" id="containsDisplay_compact_tab" href="#contains" class="containsDisplay_tab active">compact</a>
                            </li>
                            <li class="tab-item">
                                <a data-containsDisplay="module" id="containsDisplay_module_tab" href="#contains" class="containsDisplay_tab">by module</a>
                            </li>
                        </ul>
                        
                        <div id="containsDisplay_compact" class="containsDisplay active facetTabbedContent">
                            <xsl:for-each select="$childs/self::tei:elementSpec">
                                <xsl:sort select="@ident" data-type="text"/>
                                <xsl:variable name="current.elem" select="@ident" as="xs:string"/>
                                <xsl:variable name="current.elem.lowercase" select="lower-case($current.elem)" as="xs:string"/>
                                <xsl:variable name="desc" select="normalize-space(string-join(tei:desc//text(),' '))" as="xs:string"/>
                                <xsl:if test="position() gt 1">
                                    <xsl:value-of select="', '"/>
                                </xsl:if>
                                <span class="ident element" title="{$desc}">
                                    <a class="link_odd_elementSpec" href="{$version}/elements/{$current.elem.lowercase}.html"><xsl:value-of select="$current.elem"/></a>
                                </span>
                            </xsl:for-each>
                        </div>
                        <div id="containsDisplay_module" class="containsDisplay facetTabbedContent">
                            <xsl:for-each select="distinct-values($childs/self::tei:elementSpec/@module)">
                                <xsl:sort select="." data-type="text"/>
                                <xsl:variable name="current.module" select="." as="xs:string"/>
                                <xsl:variable name="relevant.element.names" select="distinct-values($childs/self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                                <div class="moduleBox">
                                    <div class="classHeading">
                                        <label class="groupLabel"><xsl:value-of select="$current.module"/></label>
                                        <span class="groupDesc"><xsl:value-of select="normalize-space(string-join($mei.source//tei:moduleSpec[@ident = $current.module]/tei:desc/text(),' '))"/></span>
                                    </div>
                                    
                                    <xsl:for-each select="$relevant.element.names">
                                        <xsl:sort select="." data-type="text"/>
                                        <xsl:variable name="current.elem" select="." as="xs:string"/>
                                        <xsl:variable name="current.elem.lowercase" select="lower-case(.)" as="xs:string"/>
                                        
                                        <div class="elementRef">
                                            <a class="link_odd_elementSpec" href="{$version}/elements/{$current.elem.lowercase}.html"><xsl:value-of select="$current.elem"/></a>
                                            <span class="elementDesc">
                                                <xsl:apply-templates select="$elements/self::tei:elementSpec[@ident = $current.elem]/tei:desc" mode="#current"/>
                                            </span>
                                        </div>
                                    </xsl:for-each>
                                    
                                </div> 
                                
                            </xsl:for-each>
                        </div>
                        
                    </div>
                </div>
                
                <xsl:if test="$element/tei:remarks">
                    <div class="facet remarks">
                        <div class="label">Remarks</div>
                        <div class="statement remarks">
                            <p><xsl:apply-templates select="$element/tei:remarks/tei:p/node()"/></p>
                        </div>
                    </div>
                </xsl:if>
                
                <xsl:if test="$element//tei:constraintSpec">
                    <div class="facet constraints" id="constraints">
                        <div class="label">Constraints</div>
                        <div class="statement constraints">
                            
                            <ul class="tab">
                                <li class="tab-item">
                                    <a data-constraintsDisplay="text" id="constraintsDisplay_text_tab" href="#constraints" class="constraintsDisplay_tab active">text</a>
                                </li>
                                <li class="tab-item">
                                    <a data-constraintsDisplay="schematron" id="constraintsDisplay_schematron_tab" href="#constraints" class="constraintsDisplay_tab">schematron</a>
                                </li>
                            </ul>
                            
                            <div id="constraintsDisplay_text" class="constraintsDisplay active facetTabbedContent">
                                <xsl:for-each select="$element//tei:constraintSpec">
                                    <div class="constraint">
                                        <xsl:for-each select=".//sch:assert">
                                            <div class="schematronText"><xsl:value-of select="normalize-space(string-join(.//text(),' '))"/></div>
                                        </xsl:for-each>
                                    </div>
                                </xsl:for-each>
                            </div>
                                
                            <div id="constraintsDisplay_schematron" class="constraintsDisplay facetTabbedContent">
                                <xsl:for-each select="$element//tei:constraintSpec">
                                    <div class="constraint">
                                        <div class="code" xml:space="preserve" data-lang="Schematron"><code><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></code></div>
                                    </div>
                                </xsl:for-each>
                            </div>
                            
                        </div>
                    </div>
                </xsl:if>
                
                <div class="facet declaration">
                    <div class="label">Declaration</div>
                    <div class="statement declaration">
                        <xsl:variable name="codeBlock">
                            <xsl:apply-templates select="$element/(tei:classes | tei:content)" mode="preserveSpace">
                                <xsl:with-param name="getODD" tunnel="yes" select="true()"/>
                            </xsl:apply-templates>
                        </xsl:variable>
                        <div class="code" xml:space="preserve" data-lang="ODD"><code><xsl:sequence select="$codeBlock"/></code></div>
                    </div>
                </div>
                
            </div>
            <script type="text/javascript">
                
                if(localStorage.getItem('meiSpecsAttDisplay') === null) {
                    setAttributeStyle('compact');
                } else {
                    setAttributeStyle(localStorage.getItem('meiSpecsAttDisplay'));
                }
                if(localStorage.getItem('meiSpecsContainedByDisplay') === null) {
                    setContainedByStyle('compact');
                } else {
                    setContainedByStyle(localStorage.getItem('meiSpecsContainedByDisplay'));
                }
                if(localStorage.getItem('meiSpecsContainsDisplay') === null) {
                    setContainsStyle('compact');
                } else {
                    setContainsStyle(localStorage.getItem('meiSpecsContainsDisplay'));
                }
                if(localStorage.getItem('meiSpecsConstraintsDisplay') === null) {
                    setConstraintsStyle('text');
                } else {
                    setConstraintsStyle(localStorage.getItem('meiSpecsConstraintsDisplay'));
                }
                
                var attTabs = document.querySelectorAll('.attDisplay_tab');
                var containedByTabs = document.querySelectorAll('.containedByDisplay_tab');
                var containsTabs = document.querySelectorAll('.containsDisplay_tab');
                var constraintsTabs = document.querySelectorAll('.constraintsDisplay_tab');
                
                var attTabClick = function(e) {
                    var style = e.target.getAttribute('data-attDisplay');
                    setAttributeStyle(style);
                };
                var containedByTabClick = function(e) {
                    var style = e.target.getAttribute('data-containedByDisplay');
                    setContainedByStyle(style);
                };
                var containsTabClick = function(e) {
                    var style = e.target.getAttribute('data-containsDisplay');
                    setContainsStyle(style);
                };
                var constraintsTabClick = function(e) {
                    var style = e.target.getAttribute('data-constraintsDisplay');
                    setConstraintsStyle(style);
                };
                
                for(var tab of attTabs) {
                    tab.addEventListener('click',attTabClick);
                }
                for(var tab of containedByTabs) {
                    tab.addEventListener('click',containedByTabClick);
                }
                for(var tab of containsTabs) {
                    tab.addEventListener('click',containsTabClick);
                }
                for(var tab of constraintsTabs) {
                    tab.addEventListener('click',constraintsTabClick);
                }
                
                function setAttributeStyle(style) {
                    console.log('setting attribute style to ' + style)
                    localStorage.setItem('meiSpecsAttDisplay',style);
                    
                    var oldTab = document.querySelector('.active.attDisplay_tab');
                    oldTab.classList.remove('active');
                    
                    var newTab = document.getElementById('attDisplay_' + style + '_tab');
                    newTab.classList.add('active');
                    
                    var oldBox = document.querySelector('.active.attDisplay');
                    oldBox.classList.remove('active');
                    oldBox.style.display = 'none';
                    
                    var newBox = document.getElementById('attDisplay_' + style);
                    newBox.classList.add('active');
                    newBox.style.display = 'block';
                }
                
                function setContainedByStyle(style) {
                    console.log('setting containedBy style to ' + style)
                    localStorage.setItem('meiSpecsContainedByDisplay',style);
                    
                    var oldTab = document.querySelector('.active.containedByDisplay_tab');
                    oldTab.classList.remove('active');
                    
                    var newTab = document.getElementById('containedByDisplay_' + style + '_tab');
                    newTab.classList.add('active');
                    
                    var oldBox = document.querySelector('.active.containedByDisplay');
                    oldBox.classList.remove('active');
                    oldBox.style.display = 'none';
                    
                    var newBox = document.getElementById('containedByDisplay_' + style);
                    newBox.classList.add('active');
                    newBox.style.display = 'block';
                }
                function setContainsStyle(style) {
                    console.log('setting contains style to ' + style)
                    localStorage.setItem('meiSpecsContainsDisplay',style);
                    
                    var oldTab = document.querySelector('.active.containsDisplay_tab');
                    oldTab.classList.remove('active');
                    
                    var newTab = document.getElementById('containsDisplay_' + style + '_tab');
                    newTab.classList.add('active');
                    
                    var oldBox = document.querySelector('.active.containsDisplay');
                    oldBox.classList.remove('active');
                    oldBox.style.display = 'none';
                    
                    var newBox = document.getElementById('containsDisplay_' + style);
                    newBox.classList.add('active');
                    newBox.style.display = 'block';
                }
                function setConstraintsStyle(style) {
                    console.log('setting constraints style to ' + style)
                    localStorage.setItem('meiSpecsConstraintsDisplay',style);
                    
                    var oldTab = document.querySelector('.active.constraintsDisplay_tab');
                    oldTab.classList.remove('active');
                    
                    var newTab = document.getElementById('constraintsDisplay_' + style + '_tab');
                    newTab.classList.add('active');
                    
                    var oldBox = document.querySelector('.active.constraintsDisplay');
                    oldBox.classList.remove('active');
                    oldBox.style.display = 'none';
                    
                    var newBox = document.getElementById('constraintsDisplay_' + style);
                    newBox.classList.add('active');
                    newBox.style.display = 'block';
                }
            </script>
        </div>
    </xsl:template>
    
    <xsl:function name="tools:handleAttributes" as="node()*">
        <xsl:param name="current.element" as="node()"/>
        
        <xsl:if test="$current.element//tei:attDef">
            <div class="attributes direct" data-module="{$current.element/@module}">
                <xsl:for-each select="$current.element//tei:attDef">
                    <xsl:variable name="current.att" select="." as="node()"/>
                    <xsl:sequence select="tools:resolveAttDef($current.att,$current.element/@module)"/>
                </xsl:for-each>
            </div>
        </xsl:if>
        
        <xsl:sequence select="for $attClass in $current.element//tei:memberOf[starts-with(@key,'att.')]/@key return tools:resolveAttClass($attClass, $current.element/@ident)"/>
        
    </xsl:function>
    
    <xsl:function name="tools:resolveAttClass" as="node()*">
        <xsl:param name="class.name" as="xs:string"/>
        <xsl:param name="parent" as="xs:string"/>
        <xsl:variable name="att.class" select="$att.classes[@ident = $class.name]" as="node()"/>
        
        <div class="attributes class" data-ident="{$att.class/@ident}" data-parent="{$parent}" data-module="{$att.class/@module}">
            <div class="classHeading">
                <label class="groupLabel"><xsl:value-of select="$att.class/@ident"/></label>
                <span class="groupDesc"><xsl:value-of select="normalize-space(string-join($att.class/tei:desc/text(),' '))"/></span>
            </div>
            <xsl:for-each select="$att.class//tei:attDef">
                <xsl:variable name="current.att" select="." as="node()"/>
                <xsl:sequence select="tools:resolveAttDef($current.att,$att.class/@module)"/>
            </xsl:for-each>
            <xsl:sequence select="for $inherited.class in $att.class//tei:memberOf[starts-with(@key,'att.')]/@key return tools:resolveAttClass($inherited.class,$class.name)"/>
        </div>
    </xsl:function>
    
    <xsl:function name="tools:resolveAttDef" as="node()">
        <xsl:param name="current.att" as="node()"/>
        <xsl:param name="module" as="xs:string"/>
        <xsl:variable name="usage" select="if($current.att/@usage = 'opt') then('optional') else if($current.att/@usage = 'req') then('required') else($current.att/@usage)" as="xs:string?"/>
        
        <div class="attributeDef" data-ident="{$current.att/@ident}" data-module="{$module}">
            <span class="ident attribute"><xsl:value-of select="$current.att/@ident"/></span>
            <xsl:if test="$usage">
                <span class="attributeUsage">(<xsl:value-of select="$usage"/>)</span>
            </xsl:if>
            <span class="attributeDesc"><xsl:apply-templates select="$current.att/tei:desc/node()"/></span>
            <span class="attributeValues">
                <xsl:choose>
                    <xsl:when test="$current.att/tei:valList">
                        Allowed values are:
                        <xsl:for-each select="$current.att/tei:valList/tei:valItem">
                            <xsl:if test="position() gt 1">, </xsl:if> "<span style="font-weight: 500;"><xsl:value-of select="@ident"/></span>" <xsl:if test="tei:desc"> <i>(<xsl:value-of select="tei:desc/text()"/>)</i></xsl:if>
                        </xsl:for-each>
                        <xsl:if test="$current.att/tei:valList/@type = 'semi' and $current.att/tei:dataType/rng:data[@type = 'NMTOKEN']">
                            and custom <i>NMToken</i>
                        </xsl:if>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:ref]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/@maxOccurs = '1'">
                                Value conforms to <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = '2'">
                                One or two values from <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by a space.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                                One or more values from <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by spaces.
                            </xsl:when>
                            <xsl:when test="not($dt/@maxOccurs) and not($dt/@minOccurs)">
                                Value conforms to <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:data]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/@maxOccurs = '1'">
                                Value of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = '2'">
                                One or two values of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>, separated by a space.
                            </xsl:when>
                            <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                                One or more values of datatype <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>, separated by spaces.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:ref) = 1 and $dt/child::rng:ref/@type = 'string'">
                                Value is plain text.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'string'">
                                Value is plain text.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'ID'">
                                Value is a valid <a target="_blank" href="https://www.w3.org/TR/xml-id/">xml:id</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'decimal'">
                                Value is a decimal number.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'integer'">
                                Value is an integer.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'positiveInteger'">
                                Value is a positive integer.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'nonNegativeInteger'">
                                Value is a positive integer, including 0.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'language'">
                                Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#language">language</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token'">
                                Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#token">token</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'NMTOKEN'">
                                Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#NMTOKEN">NMTOKEN</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'duration'">
                                Value is an <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#duration">ISO duration</a>.
                            </xsl:when>
                            <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token' and $dt/child::rng:data/child::rng:param[@name='pattern']">
                                Value conforms to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:list]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[@type='token']/rng:param[@name='pattern']">
                                One or more values conforming to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                            </xsl:when>
                            <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 2">
                                One or more values, each consisting of a sequence of <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span> and <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[2])"/></span> sub-values.
                            </xsl:when>
                            <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 1">
                                One or more of <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.
                            </xsl:when>
                            <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[following-sibling::rng:ref]">
                                One or more values, each consisting of a sequence of a <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data)"/></span> part, followed by a <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt//rng:ref/@name)}.html"><xsl:value-of select="$dt//rng:ref/@name"/></a>.
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:choice]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="$dt/rng:choice[count(child::rng:data) = 2]">
                                Value must either conform to <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span> or <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[2])"/></span>.                            
                            </xsl:when>
                            <xsl:when test="$dt/rng:choice[count(child::*) = 1]">
                                Value must conform to <span style="font-weight: 500;"><xsl:sequence select="tools:resolveData($dt//rng:data[1])"/></span>.                            
                            </xsl:when>
                            <xsl:when test="$dt/rng:choice[count(child::*) = 2 and rng:ref[@name = 'data.BOOLEAN'] and rng:value]">
                                Value must conform to <span style="font-weight: 500;">data.BOOLEAN</span> or <span style="font-weight: 500;"><xsl:value-of select="$dt/rng:choice/rng:value/text()"/></span>.                            
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="yes" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="$current.att/tei:datatype[rng:text]">
                        <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                        <xsl:choose>
                            <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and $dt/@maxOccurs = '1'">
                                Value is plain text.
                            </xsl:when>
                            <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and not($dt/@maxOccurs)">
                                Value is plain text.
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                                <xsl:message terminate="no" select="$dt"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message select="'WARNING: Not sure how to resolve the values of attDef ' || $current.att/@ident"/>
                    </xsl:otherwise>
                </xsl:choose>
            </span>
        </div>
        
    </xsl:function>
    
    <xsl:function name="tools:resolveData" as="node()+">
        <xsl:param name="data" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="not($data/child::*)">
                <xsl:value-of select="$data/@type"/>
            </xsl:when>
            <xsl:when test="$data/@type = ('string','token') and $data/rng:param[@name = 'pattern']">
                a string matching the following regular expression: "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a decimal number between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a positive integer between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'maxInclusive']">
                a positive integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'minInclusive']">
                a positive integer no smaller than <xsl:value-of select="$data/rng:param/text()" />
            </xsl:when>
            <xsl:when test="$data/@type = 'nonNegativeInteger' and $data/rng:param[@name = 'maxInclusive']">
                a non-negative integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive']">
                a decimal number no smaller than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minExclusive']">
                a decimal number larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'pattern']">
                one of the following integers: <xsl:value-of select="string-join(tokenize($data/rng:param/text(),'|'),', ')"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'pattern']">
                a decimal number matching the pattern "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'ERROR: Cannot resolve the following datatype:'"/>
                <xsl:message terminate="yes" select="$data"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="tools:getParents" as="node()*">
        <xsl:param name="model.classes" as="node()*"/>
        
        <xsl:for-each select="$model.classes">
            <xsl:variable name="current.model" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[(:.//tei:memberOf[@key = $current.model/@ident] or :).//tei:content//rng:ref[@name = $current.model/@ident]]" as="node()*"/>
            <!--<xsl:message select="'  INFO: looking for ' || count($relevant.elements) || ' elements in ' || $current.model/@ident"/>-->
            <xsl:sequence select="$relevant.elements"/>
            <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'model' and @ident = $current.model//tei:memberOf/@key]" as="node()*"/>
            <xsl:sequence select="tools:getParents($inheriting.classes)"/>
        </xsl:for-each>
    </xsl:function>
    
    <xsl:function name="tools:getChilds" as="node()*">
        <xsl:param name="className" as="xs:string"/>
        <xsl:sequence select="$elements/self::tei:elementSpec[.//tei:memberOf[@key = $className]]"/>
        
        <xsl:variable name="inheriting.models" select="$model.classes/self::tei:classSpec[.//tei:memberOf/@key = $className]/@ident" as="xs:string*"/>
        <xsl:for-each select="$inheriting.models">
            <xsl:sequence select="tools:getChilds(.)"/>    
        </xsl:for-each>
        
    </xsl:function>


    <xsl:template match="egx:egXML" mode="preserveSpace" priority="5">
        <xsl:copy-of select="node()"/>
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="element()" mode="preserveSpace" priority="1">
        <xsl:param name="indent" as="xs:integer?"/>
        <xsl:variable name="indent.level" select="if($indent) then($indent) else(1)" as="xs:integer"/>
        <xsl:variable name="element" select="." as="node()"/>
        <xsl:choose>
            <xsl:when test="local-name() = 'param' and @name = 'pattern' and string-length(text()) gt 30">
                <div class="indent{$indent.level} indent"><span data-indentation="{$indent.level}" class="element">&lt;<xsl:value-of select="name($element)"/><xsl:apply-templates select="$element/@*" mode="#current"/>&gt;</span>
                    <xsl:choose>
                        <xsl:when test="string-length(text()) gt 240">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),121,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),181,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),241,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 180">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),121,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),181,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 120">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),121,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 60">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 30">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,100)"/></div>        
                        </xsl:when>
                    </xsl:choose>
                <span data-indentation="{$indent.level}" class="element">&lt;/<xsl:value-of select="name($element)"/>&gt;</span></div>
            </xsl:when>
            <xsl:otherwise>
                <div class="indent{$indent.level} indent"><span data-indentation="{$indent.level}" class="element">&lt;<xsl:value-of select="name($element)"/><xsl:apply-templates select="$element/@*" mode="#current"/><xsl:if test="not($element/node())">/</xsl:if>&gt;</span><xsl:apply-templates select="$element/node()" mode="#current"><xsl:with-param name="indent" select="$indent.level + 1" as="xs:integer"/></xsl:apply-templates><xsl:if test="$element/node()"><span data-indentation="{$indent.level}" class="element">&lt;/<xsl:value-of select="name($element)"/>&gt;</span></xsl:if></div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="comment()" mode="preserveSpace" priority="1">
        <xsl:param name="indent" as="xs:integer?"/>
        <xsl:variable name="indent.level" select="if($indent) then($indent) else(1)" as="xs:integer"/>
        <xsl:variable name="element" select="." as="node()"/>
        <div class="indent{$indent.level} indent"><span data-indentation="{$indent.level}" class="comment">&lt;!--<xsl:value-of select="."/>--&gt;</span></div>   
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="@*" mode="preserveSpace" priority="1"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="name()"/>=</span><span class="attributevalue">"<xsl:value-of select="string(.)"/>"</span></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="tei:memberOf/@key" mode="preserveSpace" priority="2" xml:space="preserve">
        <xsl:choose>
            <xsl:when test="starts-with(string(.),'att.')"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/attribute-classes/{lower-case(string(.))}.html"><xsl:value-of select="normalize-space(string(.))"/></a>"</span></span></xsl:when>
            <xsl:when test="starts-with(string(.),'model.')"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/model-classes/{lower-case(string(.))}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:otherwise><xsl:message terminate="yes" select="'Dunno how to resolve memberOf reference ' || ."/></xsl:otherwise>
        </xsl:choose></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="tei:macroRef/@key" mode="preserveSpace" priority="2" xml:space="preserve"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/data-types/{lower-case(string(.))}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="rng:ref/@name" mode="preserveSpace" priority="2" xml:space="preserve">
        <xsl:variable name="target.type" as="xs:string"><xsl:choose>
                <xsl:when test="starts-with(.,'model.')"><xsl:value-of select="'model'"/></xsl:when>
                <xsl:when test="starts-with(.,'macro.')"><xsl:value-of select="'macro'"/></xsl:when>
                <xsl:when test="starts-with(.,'data.')"><xsl:value-of select="'macro'"/></xsl:when>
                <xsl:when test=". = $mei.source//tei:elementSpec/@ident"><xsl:value-of select="'element'"/></xsl:when>
                <xsl:otherwise><xsl:value-of select="'other'"/></xsl:otherwise>
            </xsl:choose></xsl:variable>
        <xsl:choose>
            <xsl:when test="$target.type = 'element'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/elements/{lower-case(string(.))}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:when test="$target.type = 'model'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/model-classes/{lower-case(string(.))}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:when test="$target.type = 'macro'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/data-types/{lower-case(string(.))}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:when test="$target.type = 'other'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<xsl:value-of select="string(.)"/>"</span></span></xsl:when>
        </xsl:choose>
    </xsl:template>
        
     <xsl:template match="@mode[not(ancestor::egx:egXML)]" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for elementSpec's ODD -->
    <xsl:template match="tei:elementSpec//@ns | tei:elementSpec//@predeclare | tei:elementSpec//@status | tei:elementSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for classSpec's ODD -->
    <xsl:template match="tei:classSpec//@ns | tei:classSpec//@predeclare | tei:classSpec//@status | tei:classSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for macroSpec's ODD -->
    <xsl:template match="tei:macroSpec//@ns | tei:macroSpec//@predeclare | tei:macroSpec//@status | tei:macroSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- the following templates are used to support the unicode "reverse solidus overlay" character (u20E5) -->
    <xsl:template match="tei:p[following-sibling::*[1][local-name() = 'figure'][child::tei:graphic/@url = 'Images/modules/harmony/figuredBass05.png']]/text()" priority="1">
        <xsl:choose>
            <xsl:when test="contains(.,'⃥')">
                <xsl:value-of select="substring-before(.,'⃥')"/><span class="reverseSolidus">⃥</span><xsl:value-of select="substring-after(.,'⃥')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*:egXML/*:harm/*:fb/*:f/text()" mode="#all" priority="1">
        <xsl:choose>
            <xsl:when test="contains(.,'⃥')">
                <xsl:value-of select="substring-before(.,'⃥')"/><span class="reverseSolidus">⃥</span><xsl:value-of select="substring-after(.,'⃥')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:gi">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="$text = $elements/@ident">
                <a class="link_odd_elementSpec" href="{$version}/elements/{lower-case($text)}.html"><xsl:value-of select="$text"/></a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'WARNING: Unable to retrieve definition of element ' || $text || '. No link created. Please check spelling…'"/>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="tei:ident[@type = 'class']">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="$text = //tei:classSpec/@ident">
                <xsl:variable name="link">
                    <xsl:choose>
                        <xsl:when test="starts-with($text,'model.')">
                            <xsl:call-template name="linkToModel">
                                <xsl:with-param name="model" select="$text"/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="linkToAttribute">
                                <xsl:with-param name="att" select="$text"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <a class="link_odd" href="{$link}"><xsl:value-of select="$text"/></a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no" select="'ERROR: Unable to identify class ' || $text || ' from tei:ident element. No link created.'"/>
                <span class="ident">
                    <xsl:apply-templates select="node()" mode="#current"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="tei:att">
        <span class="att"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    <xsl:template match="tei:emph">
        <em class="mentioned"><xsl:apply-templates select="node()" mode="#current"/></em>
    </xsl:template>
    <xsl:template match="tei:term">
        <span class="term"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    <xsl:template match="tei:val">
        <span class="val"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template name="linkToModel">
        <xsl:param name="model" as="xs:string"/>
        <xsl:value-of select="$version || '/model-classes/' || lower-case($model) || '.html'"/>
    </xsl:template>
    <xsl:template name="linkToAttribute">
        <xsl:param name="att" as="xs:string"/>
        <xsl:value-of select="$version || '/attribute-classes/' || lower-case($att) || '.html'"/>
    </xsl:template>
    
    

</xsl:stylesheet>